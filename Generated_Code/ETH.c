/* ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : ETH.c
**     Project     : PersonalCloud
**     Processor   : MK64FN1M0VLQ12
**     Component   : Ethernet_LDD
**     Version     : Component 01.102, Driver 01.05, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2015-02-12, 14:36, # CodeGen: 1
**     Abstract    :
**          This component implements an ethernet controller driver
**          interface. Controls the transmission and reception of
**          ethernet frame fragments.
**     Settings    :
**          Component name                                 : ETH
**          Device                                         : ENET
**          Settings                                       : 
**            Interface                                    : RMII
**              Management bus                             : Enabled
**                Clock frequency                          : 2.5 MHz
**                Preamble drop                            : Enabled
**                Holdtime                                 : 8 bus cycles
**              RMII speed                                 : 100 Mbps
**            MAC address                                  : 00:00:00:00:00:00
**            Duplex mode                                  : Full duplex
**            Flow control                                 : Enabled
**              Pause frame duration                       : 0
**            Internal loopback                            : Disabled
**            IEEE 1588                                    : Disabled
**            Frame                                        : 
**              Maximum length                             : 1518
**              Truncation length                          : 2048
**              Transmit                                   : 
**                Append CRC                               : yes
**                Insert MAC address                       : no
**                Inter-packet gap                         : 8
**                Insert IP header checksum                : Disabled
**                Insert protocol checksum                 : Disabled
**                Payload alignment                        : Disabled
**              Receive                                    : 
**                Forward CRC                              : yes
**                Payload alignment                        : Disabled
**                Payload length check                     : Disabled
**                Remove padding                           : no
**                Remove padding in short IP frames        : no
**                Filter                                   : 
**                  Control frames                         : Accept
**                  Pause frames                           : Accept
**                  Invalid frames                         : Accept
**                  Wrong IP header checksum               : Accept
**                  Wrong protocol checksum                : Accept
**            Address filter                               : Enabled
**              Broadcast frames                           : Accept
**              Unicast addresses                          : (string list)
**              Multicast addresses                        : (string list)
**            Statistics                                   : Enabled
**              Remote network monitoring                  : Enabled
**              IEEE                                       : Enabled
**            DMA                                          : 
**              Transmit                                   : 
**                Watermark                                : Store and forward
**                Section empty threshold                  : 0
**                Almost empty threshold                   : 8
**                Almost full threshold                    : 8
**              Receive                                    : 
**                Section full threshold                   : 0
**                Section empty threshold                  : 0
**                Almost empty threshold                   : 8
**                Almost full threshold                    : 8
**            Buffers                                      : 
**              Transmit buffer queue size                 : 7
**              Receive buffer queue size                  : 7
**              Receive buffer size                        : 0
**          Interrupt service/event                        : Enabled
**            Transmit                                     : 
**              Transmit frame                             : INT_ENET_Transmit
**              Transmit frame priority                    : medium priority
**            Receive                                      : 
**              Receive frame                              : INT_ENET_Receive
**              Receive frame priority                     : medium priority
**            Others                                       : 
**              MII & Ethernet bus error & Wake-up         : INT_ENET_Error
**              MII & Ethernet bus error & Wake-up priority : medium priority
**          Pins                                           : RMII
**            Management                                   : Enabled
**              MDC pin                                    : ADC0_SE9/ADC1_SE9/PTB1/I2C0_SDA/FTM1_CH1/RMII0_MDC/MII0_MDC/FTM1_QD_PHB
**              MDC pin signal                             : 
**              MDIO pin                                   : ADC0_SE8/ADC1_SE8/PTB0/LLWU_P5/I2C0_SCL/FTM1_CH0/RMII0_MDIO/MII0_MDIO/FTM1_QD_PHA
**              MDIO pin signal                            : 
**            Transmit                                     : 
**              TXD0 pin                                   : PTA16/SPI0_SOUT/UART0_CTS_b/UART0_COL_b/RMII0_TXD0/MII0_TXD0/I2S0_RX_FS/I2S0_RXD1
**              TXD0 pin signal                            : 
**              TXD1 pin                                   : ADC1_SE17/PTA17/SPI0_SIN/UART0_RTS_b/RMII0_TXD1/MII0_TXD1/I2S0_MCLK
**              TXD1 pin signal                            : 
**              TXEN pin                                   : PTA15/SPI0_SCK/UART0_RX/RMII0_TXEN/MII0_TXEN/I2S0_RXD0
**              TXEN pin signal                            : 
**            Receive                                      : 
**              RXDV_CRS pin                               : PTA14/SPI0_PCS0/UART0_TX/RMII0_CRS_DV/MII0_RXDV/I2C2_SCL/I2S0_RX_BCLK/I2S0_TXD1
**              RXDV_CRS pin signal                        : 
**              RXD0 pin                                   : CMP2_IN1/PTA13/LLWU_P4/CAN0_RX/FTM1_CH1/RMII0_RXD0/MII0_RXD0/I2C2_SDA/I2S0_TX_FS/FTM1_QD_PHB
**              RXD0 pin signal                            : 
**              RXD1 pin                                   : CMP2_IN0/PTA12/CAN0_TX/FTM1_CH0/RMII0_RXD1/MII0_RXD1/I2C2_SCL/I2S0_TXD0/FTM1_QD_PHA
**              RXD1 pin signal                            : 
**              RXER                                       : Disabled
**            REF_CLK pin                                  : EXTAL0/PTA18/FTM0_FLT2/FTM_CLKIN0
**            REF_CLK pin signal                           : 
**          Initialization                                 : 
**            Enable device                                : yes
**            Auto initialization                          : yes
**            Event mask                                   : 
**              OnFrameTransmitted                         : Enabled
**              OnFrameReceived                            : Enabled
**              OnFrameTransmittedTimestamped              : Disabled
**              OnFrameReceivedTimestamped                 : Disabled
**              OnMIIFinished                              : Disabled
**              OnWakeUp                                   : Disabled
**              OnFatalError                               : Enabled
**            Sleep mode                                   : Disabled
**            Debug                                        : Disabled
**          CPU clock/configuration selection              : 
**            Clock configuration 0                        : This component enabled
**            Clock configuration 1                        : This component disabled
**            Clock configuration 2                        : This component disabled
**            Clock configuration 3                        : This component disabled
**            Clock configuration 4                        : This component disabled
**            Clock configuration 5                        : This component disabled
**            Clock configuration 6                        : This component disabled
**            Clock configuration 7                        : This component disabled
**     Contents    :
**         Init         - LDD_TDeviceData* ETH_Init(LDD_TUserData *UserDataPtr);
**         Deinit       - void ETH_Deinit(LDD_TDeviceData *DeviceDataPtr);
**         SendFrame    - LDD_TError ETH_SendFrame(LDD_TDeviceData *DeviceDataPtr, LDD_ETH_TBufferDesc...
**         ReceiveFrame - LDD_TError ETH_ReceiveFrame(LDD_TDeviceData *DeviceDataPtr, uint8_t*...
**
**     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
**     All Rights Reserved.
**     
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**     
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**     
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**     
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**     
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**     
**     http: www.freescale.com
**     mail: support@freescale.com
** ###################################################################*/
/*!
** @file ETH.c
** @version 01.05
** @brief
**          This component implements an ethernet controller driver
**          interface. Controls the transmission and reception of
**          ethernet frame fragments.
*/         
/*!
**  @addtogroup ETH_module ETH module documentation
**  @{
*/         

/* MODULE ETH */

/*lint -save  -e961 -e572 -e648 Disable MISRA rule (12.1,12.8,12.11) checking. */

/* {Default RTOS Adapter} No RTOS includes */
#include "ETH.h"
#include "IO_Map.h"
#include "ENET_PDD.h"
#include "Events.h"

#ifdef __cplusplus
extern "C" {
#endif 

/* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
static ETH_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
/* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
static ETH_TDeviceData* INT_ENET_Transmit__DEFAULT_RTOS_ISRPARAM;
/* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
static ETH_TDeviceData* INT_ENET_Receive__DEFAULT_RTOS_ISRPARAM;
/* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
static ETH_TDeviceData* INT_ENET_Error__DEFAULT_RTOS_ISRPARAM;

/*
** ===================================================================
**     Method      :  ETH_Init (component Ethernet_LDD)
*/
/*!
**     @brief
**         Initializes the device. Allocates memory for the device data
**         structure, allocates interrupt vectors and sets interrupt
**         priority, sets pin routing, sets timing, etc. If the
**         property <"Enable device"> is set to "yes" then the device
**         is also enabled (see the description of the <Enable> method).
**         In this case the <Enable> method is not necessary and need
**         not to be generated. This method can be called only once.
**         Before the second call of Init the <Deinit> method must be
**         called first.
**     @param
**         UserDataPtr     - Pointer to a user data
**                           structure.
**     @return
**                         - Pointer to the device data structure. 
*/
/* ===================================================================*/
LDD_TDeviceData* ETH_Init(LDD_TUserData *UserDataPtr)
{
  ETH_TDeviceData *DeviceDataPrv;
  ETH_TTxQueueItem *TxQueueItemPtr;
  ETH_TRxQueueItem *RxQueueItemPtr;
  uint8_t* MemPtr;
  /* Allocate internal device data structure */
  /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer to the static object */
  DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;

  DeviceDataPrv->DuplexMode = LDD_ETH_FULL_DUPLEX; /* Store duplex mode configuration */
  DeviceDataPrv->FilterMode = LDD_ETH_ACCEPT_BC; /* Store filter mode configuration */
  DeviceDataPrv->SleepMode = LDD_ETH_DISABLED; /* Store sleep mode configuration */
  DeviceDataPrv->UserDataPtr = UserDataPtr; /* Store the RTOS device structure */
  DeviceDataPrv->Index = 0U;           /* Set the component instance index */
  DeviceDataPrv->EventMask =           /* Initialize the event mask */
    LDD_ETH_ON_FRAME_TRANSMITTED |
    LDD_ETH_ON_FRAME_RECEIVED |
    LDD_ETH_ON_FATAL_ERROR |0U;
  DeviceDataPrv->EnabledMode = TRUE;   /* Enable the device clock configuration */
  /* SIM_SCGC2: ENET=1 */
  SIM_SCGC2 |= SIM_SCGC2_ENET_MASK;
  ENET_PDD_DisableDevice(ENET_BASE_PTR);
  DeviceDataPrv->Enabled = FALSE;
  ENET_PDD_EnableMIBCounters(ENET_BASE_PTR, FALSE); /* Disable statistic counters */
  ENET_PDD_ClearMIBCounters(ENET_BASE_PTR); /* Clear statistic  counters */
  ENET_PDD_EnableMIBCounters(ENET_BASE_PTR, TRUE); /* Enable statistic counters */
  /* Set pin assignments */
  /* PORTB_PCR1: ISF=0,MUX=4 */
  PORTB_PCR1 = (uint32_t)((PORTB_PCR1 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x03)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x04)
               ));
  /* PORTB_PCR0: ISF=0,MUX=4 */
  PORTB_PCR0 = (uint32_t)((PORTB_PCR0 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x03)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x04)
               ));
  /* PORTA_PCR18: ISF=0,MUX=0 */
  PORTA_PCR18 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
  /* PORTA_PCR16: ISF=0,MUX=4 */
  PORTA_PCR16 = (uint32_t)((PORTA_PCR16 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x03)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x04)
                ));
  /* PORTA_PCR17: ISF=0,MUX=4 */
  PORTA_PCR17 = (uint32_t)((PORTA_PCR17 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x03)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x04)
                ));
  /* PORTA_PCR15: ISF=0,MUX=4 */
  PORTA_PCR15 = (uint32_t)((PORTA_PCR15 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x03)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x04)
                ));
  /* PORTA_PCR14: ISF=0,MUX=4 */
  PORTA_PCR14 = (uint32_t)((PORTA_PCR14 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x03)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x04)
                ));
  /* PORTA_PCR13: ISF=0,MUX=4 */
  PORTA_PCR13 = (uint32_t)((PORTA_PCR13 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x03)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x04)
                ));
  /* PORTA_PCR12: ISF=0,MUX=4 */
  PORTA_PCR12 = (uint32_t)((PORTA_PCR12 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x03)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x04)
                ));
  /* Set interrupt priorities */
  /* NVICIP83: PRI83=0x70 */
  NVICIP83 = NVIC_IP_PRI83(0x70);
  /* NVICISER2: SETENA|=0x00080000 */
  NVICISER2 |= NVIC_ISER_SETENA(0x00080000);
  /* NVICIP84: PRI84=0x70 */
  NVICIP84 = NVIC_IP_PRI84(0x70);
  /* NVICISER2: SETENA|=0x00100000 */
  NVICISER2 |= NVIC_ISER_SETENA(0x00100000);
  /* NVICIP85: PRI85=0x70 */
  NVICIP85 = NVIC_IP_PRI85(0x70);
  /* NVICISER2: SETENA|=0x00200000 */
  NVICISER2 |= NVIC_ISER_SETENA(0x00200000);
  /* Set interrupt mask */
  /* ENET_EIMR: ??=0,BABR=0,BABT=0,GRA=0,TXF=1,TXB=0,RXF=1,RXB=0,MII=0,EBERR=1,LC=0,RL=0,UN=0,PLR=0,WAKEUP=0,TS_AVAIL=0,TS_TIMER=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
  ENET_EIMR = (ENET_EIMR_TXF_MASK | ENET_EIMR_RXF_MASK | ENET_EIMR_EBERR_MASK);
  /* Clear interrupt flags */
  /* ENET_EIR: ??=1,BABR=1,BABT=1,GRA=1,TXF=1,TXB=1,RXF=1,RXB=1,MII=1,EBERR=1,LC=1,RL=1,UN=1,PLR=0,WAKEUP=0,TS_AVAIL=0,TS_TIMER=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
  ENET_EIR = ENET_EIR_BABR_MASK |
             ENET_EIR_BABT_MASK |
             ENET_EIR_GRA_MASK |
             ENET_EIR_TXF_MASK |
             ENET_EIR_TXB_MASK |
             ENET_EIR_RXF_MASK |
             ENET_EIR_RXB_MASK |
             ENET_EIR_MII_MASK |
             ENET_EIR_EBERR_MASK |
             ENET_EIR_LC_MASK |
             ENET_EIR_RL_MASK |
             ENET_EIR_UN_MASK |
             0x80000000U;
  /* Allocate the transmit frame interrupt vector */
  /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_ENET_Transmit__DEFAULT_RTOS_ISRPARAM = DeviceDataPrv;
  /* Allocate the receive frame interrupt vector */
  /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_ENET_Receive__DEFAULT_RTOS_ISRPARAM = DeviceDataPrv;
  /* Allocate the shared interrupt vector */
  /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_ENET_Error__DEFAULT_RTOS_ISRPARAM = DeviceDataPrv;
  /* Set MAC address */
  /* ENET_PALR: PADDR1=0 */
  ENET_PALR = ENET_PALR_PADDR1(0x00);
  /* ENET_PAUR: PADDR2=0,TYPE=0 */
  ENET_PAUR = (ENET_PAUR_PADDR2(0x00) | ENET_PAUR_TYPE(0x00));
  /* Set unicast address hash table */
  /* ENET_IAUR: IADDR1=0 */
  ENET_IAUR = ENET_IAUR_IADDR1(0x00);
  /* ENET_IALR: IADDR2=0 */
  ENET_IALR = ENET_IALR_IADDR2(0x00);
  /* Set multicast address hash table */
  /* ENET_GAUR: GADDR1=0 */
  ENET_GAUR = ENET_GAUR_GADDR1(0x00);
  /* ENET_GALR: GADDR2=0 */
  ENET_GALR = ENET_GALR_GADDR2(0x00);
  /* Set PAUSE frame duration */
  /* ENET_OPD: OPCODE=0,PAUSE_DUR=0 */
  ENET_OPD = (ENET_OPD_OPCODE(0x00) | ENET_OPD_PAUSE_DUR(0x00));
  /* Set transmit control register */
  /* ENET_TCR: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,CRCFWD=0,ADDINS=0,ADDSEL=0,RFC_PAUSE=0,TFC_PAUSE=0,FDEN=1,??=0,GTS=0 */
  ENET_TCR = (ENET_TCR_ADDSEL(0x00) | ENET_TCR_FDEN_MASK);
  /* Set transmit accelerator function configuration register */
  /* ENET_TACC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,PROCHK=0,IPCHK=0,??=0,??=0,SHIFT16=0 */
  ENET_TACC = 0x00U;
  /* Set receive control register */
  /* ENET_RCR: GRS=0,NLC=0,MAX_FL=0x05EE,CFEN=0,CRCFWD=0,PAUFWD=1,PADEN=0,??=0,??=0,RMII_10T=0,RMII_MODE=1,??=0,??=0,FCE=1,BC_REJ=0,PROM=0,MII_MODE=1,DRT=0,LOOP=0 */
  ENET_RCR = ENET_RCR_MAX_FL(0x05EE) |
             ENET_RCR_PAUFWD_MASK |
             ENET_RCR_RMII_MODE_MASK |
             ENET_RCR_FCE_MASK |
             ENET_RCR_MII_MODE_MASK;
  /* Set receive accelerator function configuration register */
  /* ENET_RACC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,SHIFT16=0,LINEDIS=0,??=0,??=0,??=0,PRODIS=0,IPDIS=0,PADREM=0 */
  ENET_RACC = 0x00U;
  /* Set transmit inter-packet gap */
  /* ENET_TIPG: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,IPG=8 */
  ENET_TIPG = ENET_TIPG_IPG(0x08);
  /* Set frame truncation length */
  /* ENET_FTRL: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,TRUNC_FL=0x0800 */
  ENET_FTRL = ENET_FTRL_TRUNC_FL(0x0800);
  /* Set transmit FIFO watermark */
  /* ENET_TFWR: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,STRFWD=1,??=0,??=0,TFWR=0 */
  ENET_TFWR = (ENET_TFWR_STRFWD_MASK | ENET_TFWR_TFWR(0x00));
  /* Set transmit FIFO section empty threshold */
  /* ENET_TSEM: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,TX_SECTION_EMPTY=0 */
  ENET_TSEM = ENET_TSEM_TX_SECTION_EMPTY(0x00);
  /* Set transmit FIFO almost empty threshold */
  /* ENET_TAEM: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,TX_ALMOST_EMPTY=8 */
  ENET_TAEM = ENET_TAEM_TX_ALMOST_EMPTY(0x08);
  /* Set transmit FIFO almost full threshold */
  /* ENET_TAFL: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,TX_ALMOST_FULL=8 */
  ENET_TAFL = ENET_TAFL_TX_ALMOST_FULL(0x08);
  /* Set receive FIFO section full threshold */
  /* ENET_RSFL: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,RX_SECTION_FULL=0 */
  ENET_RSFL = ENET_RSFL_RX_SECTION_FULL(0x00);
  /* Set receive FIFO section empty threshold */
  /* ENET_RSEM: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,STAT_SECTION_EMPTY=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,RX_SECTION_EMPTY=0 */
  ENET_RSEM = ENET_RSEM_STAT_SECTION_EMPTY(0x00) |
              ENET_RSEM_RX_SECTION_EMPTY(0x00);
  /* Set receive FIFO almost empty threshold */
  /* ENET_RAEM: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,RX_ALMOST_EMPTY=8 */
  ENET_RAEM = ENET_RAEM_RX_ALMOST_EMPTY(0x08);
  /* Set receive FIFO almost full threshold */
  /* ENET_RAFL: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,RX_ALMOST_FULL=8 */
  ENET_RAFL = ENET_RAFL_RX_ALMOST_FULL(0x08);
  /* Set MII speed control register */
  /* ENET_MSCR: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,HOLDTIME=7,DIS_PRE=1,MII_SPEED=3,??=0 */
  ENET_MSCR = ENET_MSCR_HOLDTIME(0x07) |
              ENET_MSCR_DIS_PRE_MASK |
              ENET_MSCR_MII_SPEED(0x03);
  /* Set receive buffer size */
  /* ENET_MRBR: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,R_BUF_SIZE=0,??=0,??=0,??=0,??=0 */
  ENET_MRBR = ENET_MRBR_R_BUF_SIZE(0x00);
  /* Initialize the transmit frame buffer queue */
  LDD_QUEUE_INIT(ETH_TTxQueueItem, DeviceDataPrv->TxQueue, ETH_QUEUE_MEM_ALIGN); /* Initialize the queue data structure */
  TxQueueItemPtr = LDD_QUEUE_GET_DATA_START(DeviceDataPrv->TxQueue);
  while (TxQueueItemPtr != (LDD_QUEUE_GET_DATA_END(DeviceDataPrv->TxQueue) + 1)) {
    /* Clear queue item */
    for (MemPtr = (uint8_t*)(uint32_t)TxQueueItemPtr; MemPtr != (uint8_t*)(uint32_t)(TxQueueItemPtr + 1); MemPtr++) {
      *MemPtr = 0U;
    }
    TxQueueItemPtr++;                  /* Move to the next queue item */
  }
  setReg32(ENET_TDSR, LDD_QUEUE_GET_DATA_START(DeviceDataPrv->TxQueue));
  /* Initialize the receive frame buffer queue */
  LDD_QUEUE_INIT(ETH_TRxQueueItem, DeviceDataPrv->RxQueue, ETH_QUEUE_MEM_ALIGN); /* Initialize the queue data structure */
  RxQueueItemPtr = LDD_QUEUE_GET_DATA_START(DeviceDataPrv->RxQueue);
  while (RxQueueItemPtr != (LDD_QUEUE_GET_DATA_END(DeviceDataPrv->RxQueue) + 1)) {
    /* Clear queue item */
    for (MemPtr = (uint8_t*)(uint32_t)RxQueueItemPtr; MemPtr != (uint8_t*)(uint32_t)(RxQueueItemPtr + 1); MemPtr++) {
      *MemPtr = 0U;
    }
    RxQueueItemPtr++;                  /* Move to the next queue item */
  }
  setReg32(ENET_RDSR, LDD_QUEUE_GET_DATA_START(DeviceDataPrv->RxQueue));
  /* ENET_ECR: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,DBSWP=0,STOPEN=0,DBGEN=0,??=0,EN1588=0,SLEEP=0,MAGICEN=0,ETHEREN=0,RESET=0 */
  ENET_ECR = 0x00U;
  /* Enable the device */
  ENET_PDD_EnableDevice(ENET_BASE_PTR);
  DeviceDataPrv->Enabled = TRUE;
  /* Registration of the device structure */
  PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_ETH_ID,DeviceDataPrv);
  return (LDD_TDeviceData*)DeviceDataPrv;
}

/*
** ===================================================================
**     Method      :  ETH_Deinit (component Ethernet_LDD)
*/
/*!
**     @brief
**         Deinitializes the device. Switches off the device, frees the
**         device data structure memory, interrupt vectors, etc.
**     @param
**         DeviceDataPtr   - Pointer to device data
**                           structure.
*/
/* ===================================================================*/
void ETH_Deinit(LDD_TDeviceData *DeviceDataPtr)
{
  ETH_TDeviceData *DeviceDataPrv = (ETH_TDeviceData*)DeviceDataPtr;

  (void)DeviceDataPrv;                 /* Supress unused variable warning if needed */
  /* Reset the device */
  ENET_PDD_ResetDevice(ENET_BASE_PTR);
  while (!ENET_PDD_IsResetFinished(ENET_BASE_PTR)) {}
  /* Restore the interrupt vector */
  /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
  /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
  /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
  /* Unregistration of the device structure */
  PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_ETH_ID);
  /* Deallocation of the internal device data structure */
  /* {Default RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no deallocation code is generated */
  /* SIM_SCGC2: ENET=0 */
  SIM_SCGC2 &= (uint32_t)~(uint32_t)(SIM_SCGC2_ENET_MASK);
}

/*
** ===================================================================
**     Method      :  ETH_RemoveTxFrame (component Ethernet_LDD)
**
**     Description :
**         Removes the buffers of the transmitted frame on the head of 
**         the transmit queue.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool ETH_RemoveTxFrame(LDD_TDeviceData *DeviceDataPtr)
{
  ETH_TDeviceData *DeviceDataPrv = (ETH_TDeviceData*)DeviceDataPtr;
  bool Result = FALSE;                 /* True, if a frame has been removed */
  uint16_t BufferOffset = 0U;          /* Buffer offset counter */
  uint16_t BufferCount;                /* Number of buffers in the frame on the head of the frame buffer queue */
  uint16_t Temp;                       /* Temporary variable for queue handling */

  /* Check if all buffers of a frame has been sent */
  while (!LDD_QUEUE_IS_EMPTY(DeviceDataPrv->TxQueue) &&
      !(LDD_QUEUE_GET_HEAD_OFFSET_ITEM(DeviceDataPrv->TxQueue, BufferOffset).Flags & ETH_TX_READY)) {
    if (LDD_QUEUE_GET_HEAD_OFFSET_ITEM(DeviceDataPrv->TxQueue, BufferOffset).Flags & ETH_TX_LAST_IN_FRAME) {
      ENET_PDD_ClearInterruptFlags(ENET_BASE_PTR,
        ENET_PDD_BABBLING_TX_ERROR_INT | ENET_PDD_TX_FRAME_INT |
        ENET_PDD_LATE_COLLISION_INT | ENET_PDD_COLLISION_RETRY_LIMIT_INT |
        ENET_PDD_TX_FIFO_UNDERRUN_INT);
      BufferCount = (uint16_t)(BufferOffset + 1U);
      /* Remove all buffers of the transmitted frame from the head of the queue */
      while (BufferCount--) {
        LDD_QUEUE_REMOVE_AND_DROP(DeviceDataPrv->TxQueue, Temp); /* Remove buffer from the head of the frame buffer queue */
      }
      Result = TRUE;
      break;
    }
    BufferOffset++;
  }
  return Result;
}

/*
** ===================================================================
**     Method      :  ETH_RemoveRxFrame (component Ethernet_LDD)
**
**     Description :
**         Removes the buffers of the received frame on the head of the 
**         receive queue.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool ETH_RemoveRxFrame(LDD_TDeviceData *DeviceDataPtr, uint16_t *FragCount, uint16_t *Length)
{
  ETH_TDeviceData *DeviceDataPrv = (ETH_TDeviceData*)DeviceDataPtr;
  bool Result = FALSE;                 /* True if a frame has been removed */
  uint16_t BufferOffset = 0U;          /* Buffer offset counter */
  uint16_t BufferCount;                /* Number of buffers in the frame on the head of the frame buffer queue */
  uint16_t Flags;                      /* Flags of the last buffer in a frame */
  bool Error = FALSE;                  /* Error flag */
  uint16_t Temp;                       /* Temporary variable for queue handling */

  Flags = LDD_QUEUE_GET_HEAD_OFFSET_ITEM(DeviceDataPrv->RxQueue, BufferOffset).Flags;
  /* Check if a whole frame has been received */
  while ((BufferOffset < LDD_QUEUE_GET_ITEM_COUNT(DeviceDataPrv->RxQueue, Temp)) && !(Flags & ETH_RX_EMPTY)) {
    if (Flags & ETH_RX_LAST_IN_FRAME) {
      Error = ((Flags & (ETH_RX_FRAME_TRUNCATED |
        ETH_RX_FRAME_LEN_ERROR | ETH_RX_ALIGN_ERROR |
        ETH_RX_CRC_ERROR | ETH_RX_OVERRUN)) != 0U) ? TRUE : FALSE;
      *FragCount = (uint16_t)(BufferOffset + 1U);
      /* Remove all buffers of the received frame from the head of the queue */
      for (BufferCount = *FragCount; BufferCount; BufferCount--) {
        /* Update buffer data length */
        *Length = (uint16_t)(!Error ? ETH_BE_TO_NE16(LDD_QUEUE_GET_HEAD_ITEM(DeviceDataPrv->RxQueue).Length) : 0U);
        /* Remove buffer from the head of the frame buffer queue */
        LDD_QUEUE_REMOVE_AND_DROP(DeviceDataPrv->RxQueue, Temp);
      }
      Result = TRUE;
      break;
    }
    BufferOffset++;
    Flags = LDD_QUEUE_GET_HEAD_OFFSET_ITEM(DeviceDataPrv->RxQueue, BufferOffset).Flags;
  }
  return Result;
}

/*
** ===================================================================
**     Method      :  ETH_SendFrame (component Ethernet_LDD)
*/
/*!
**     @brief
**         Initiates a frame transmission. Frame contents are defined
**         by the specified list of buffer descriptors. Frames are
**         internally queued. The end of the frame transmission is
**         signalized by the OnFrameTransmitted event.
**     @param
**         DeviceDataPtr   - Pointer to device data
**                           structure.
**     @param
**         BufferDescListPtr - Pointer to
**                           list of buffer descriptors defining
**                           contents of one frame.
**     @param
**         BufferDescCount - Number of buffer
**                           descriptors in the list.
**     @return
**                         - 
**                           Error code, possible values:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration
**                           ERR_DISABLED - The component is disabled
**                           ERR_QFULL - Frame queue is full
**                           ERR_PARAM_ADDRESS - Invalid address
**                           alignment (one or more buffer address from
**                           the list of buffer descriptors is
**                           misaligned)
**                           ERR_PARAM_LENGTH - Invalid frame length
**                           (sum of buffer sizes from the list of
**                           buffer descriptors is greater than maximum
**                           frame length)
*/
/* ===================================================================*/
LDD_TError ETH_SendFrame(LDD_TDeviceData *DeviceDataPtr, LDD_ETH_TBufferDesc *BufferDescListPtr, uint16_t BufferDescCount)
{
  ETH_TDeviceData *DeviceDataPrv = (ETH_TDeviceData*)DeviceDataPtr;
  LDD_TError Result = ERR_OK;
  ETH_TTxQueueItem TxQueueItem;
  uint16_t Index;
  uint16_t Temp;
  uint32_t LengthSum = 0UL;

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DeviceDataPrv->Enabled) {
    return ERR_DISABLED;
  }
  /* Parameter range check - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  for (Index = 0U; Index < BufferDescCount; Index++) {
    LengthSum += BufferDescListPtr[Index].Size;
    /* Buffer memory alignment (required by hardware) check */
    if (((uint32_t)BufferDescListPtr[Index].DataPtr & (ETH_QUEUE_MEM_ALIGN - 1U)) != 0U) {
      return ERR_PARAM_ADDRESS;
    }
  }
  if (LengthSum > 1518U) {
    return ERR_PARAM_LENGTH;
  }
  if (LDD_QUEUE_GET_FREE_COUNT(DeviceDataPrv->TxQueue, Temp) < BufferDescCount) {
    Result = ERR_QFULL;
  } else {
    for (Index = 0U; Index < BufferDescCount; Index++) {
      TxQueueItem.Flags = 0U;
      if (LDD_QUEUE_IS_DATA_END(DeviceDataPrv->TxQueue)) {
        TxQueueItem.Flags |= ETH_TX_WRAP; /* Indicate queue end to hardware */
      }
      if (Index == (BufferDescCount - 1U)) {
        TxQueueItem.Flags |= ETH_TX_LAST_IN_FRAME; /* Last buffer in the frame? */
      }
      TxQueueItem.Flags |= ETH_TX_APPEND_CRC; /* Append CRC after frame is transmitted */
      TxQueueItem.Length = ETH_NE_TO_BE16(BufferDescListPtr[Index].Size);
      TxQueueItem.Data = (uint8_t*)ETH_NE_TO_BE32((uint32_t)BufferDescListPtr[Index].DataPtr);
      LDD_QUEUE_INSERT(DeviceDataPrv->TxQueue, TxQueueItem, Temp);
    }
    /* Enable buffer transmission in reverse order (enable the first buffer in the frame as the last) */
    for (Index = 1U; Index <= BufferDescCount; Index++) {
      LDD_QUEUE_GET_TAIL_OFFSET_ITEM(DeviceDataPrv->TxQueue, BufferDescCount - Index).Flags |= ETH_TX_READY; /* Enable buffer transmission */
    }
    ENET_PDD_EnableTransmission(ENET_BASE_PTR);
  }
  return Result;
}

/*
** ===================================================================
**     Method      :  ETH_ReceiveFrame (component Ethernet_LDD)
*/
/*!
**     @brief
**         Initiates frame receptions. Frame contents will be placed
**         into buffers specified by the list of buffers. Frames are
**         internally queued. The end of a frame reception is
**         signalized by the OnFrameReceived event.
**     @param
**         DeviceDataPtr   - Pointer to device data
**                           structure.
**     @param
**         BufferListPtr   - Pointer to list of
**                           buffers defining where to store contents of
**                           received frames.
**     @param
**         BufferCount     - Number of buffers in the
**                           list.
**     @return
**                         - 
**                           Error code, possible values:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration
**                           ERR_DISABLED - The component is disabled
**                           ERR_QFULL - Frame queue is full
**                           ERR_PARAM_ADDRESS - Invalid address
**                           alignment (one or more buffer address from
**                           the list of buffers is misaligned)
*/
/* ===================================================================*/
LDD_TError ETH_ReceiveFrame(LDD_TDeviceData *DeviceDataPtr, uint8_t* *BufferListPtr, uint16_t BufferCount)
{
  ETH_TDeviceData *DeviceDataPrv = (ETH_TDeviceData*)DeviceDataPtr;
  LDD_TError Result = ERR_OK;
  ETH_TRxQueueItem RxQueueItem;
  uint16_t Index;
  uint16_t Temp;

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DeviceDataPrv->Enabled) {
    return ERR_DISABLED;
  }
  /* Parameter range check - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  for (Index = 0U; Index < BufferCount; Index++) {
    /* Buffer memory alignment (required by hardware) check */
    if (((uint32_t)BufferListPtr[Index] & (ETH_QUEUE_MEM_ALIGN - 1U)) != 0U) {
      return ERR_PARAM_ADDRESS;
    }
  }
  if (LDD_QUEUE_GET_FREE_COUNT(DeviceDataPrv->RxQueue, Temp) < BufferCount) {
    Result = ERR_QFULL;
  } else {
    for (Index = 0U; Index < BufferCount; Index++) {
      RxQueueItem.Flags = 0U;
      if (LDD_QUEUE_IS_DATA_END(DeviceDataPrv->RxQueue)) {
        RxQueueItem.Flags |= ETH_RX_WRAP; /* Indicate queue end to the hardware */
      }
      RxQueueItem.Data = (uint8_t*)ETH_NE_TO_BE32((uint32_t)BufferListPtr[Index]);
      LDD_QUEUE_INSERT(DeviceDataPrv->RxQueue, RxQueueItem, Temp);
    }
    /* Enable buffer reception in reverse order (enable the first buffer in the frame as the last) */
    for (Index = 1U; Index <= BufferCount; Index++) {
      LDD_QUEUE_GET_TAIL_OFFSET_ITEM(DeviceDataPrv->RxQueue, BufferCount - Index).Flags |= ETH_RX_EMPTY; /* Enable buffer reception */
    }
    ENET_PDD_EnableReception(ENET_BASE_PTR);
  }
  return Result;
}

/*
** ===================================================================
**     Method      :  ETH_InterruptTxFrame (component Ethernet_LDD)
**
**     Description :
**         Transmit frame interrupt handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(ETH_InterruptTxFrame)
{
  /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
  ETH_TDeviceData* DeviceDataPrv = INT_ENET_Transmit__DEFAULT_RTOS_ISRPARAM;

  while (ENET_PDD_GetInterruptFlags(ENET_BASE_PTR) &
      (ENET_PDD_BABBLING_TX_ERROR_INT | ENET_PDD_TX_FRAME_INT |
      ENET_PDD_LATE_COLLISION_INT | ENET_PDD_COLLISION_RETRY_LIMIT_INT |
      ENET_PDD_TX_FIFO_UNDERRUN_INT)) {
    ENET_PDD_ClearInterruptFlags(ENET_BASE_PTR, ENET_PDD_TX_FRAME_INT);
    while (ETH_RemoveTxFrame(DeviceDataPrv)) {
      ETH_OnFrameTransmitted(DeviceDataPrv->UserDataPtr);
    }
  }
  ENET_PDD_ClearInterruptFlags(ENET_BASE_PTR, ENET_PDD_GRACEFUL_STOP_COMPLETE_INT);
  ENET_PDD_FinishGracefulTxStop(ENET_BASE_PTR);
  if (!LDD_QUEUE_IS_EMPTY(DeviceDataPrv->TxQueue)) {
    ENET_PDD_EnableTransmission(ENET_BASE_PTR);
  }
}

/*
** ===================================================================
**     Method      :  ETH_InterruptRxFrame (component Ethernet_LDD)
**
**     Description :
**         Receive frame interrupt handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(ETH_InterruptRxFrame)
{
  /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
  ETH_TDeviceData* DeviceDataPrv = INT_ENET_Receive__DEFAULT_RTOS_ISRPARAM;
  uint16_t FragCount;
  uint16_t Length;

  while (ENET_PDD_GetInterruptFlags(ENET_BASE_PTR) & ENET_PDD_RX_FRAME_INT) {
    ENET_PDD_ClearInterruptFlags(ENET_BASE_PTR, ENET_PDD_RX_FRAME_INT);
    while (ETH_RemoveRxFrame(DeviceDataPrv, &FragCount, &Length)) {
      ETH_OnFrameReceived(DeviceDataPrv->UserDataPtr, FragCount, Length);
    }
  }
}

/*
** ===================================================================
**     Method      :  ETH_InterruptShared (component Ethernet_LDD)
**
**     Description :
**         Shared interrupt handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(ETH_InterruptShared)
{
  /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
  ETH_TDeviceData* DeviceDataPrv = INT_ENET_Error__DEFAULT_RTOS_ISRPARAM;

  if (ENET_PDD_GetInterruptFlags(ENET_BASE_PTR) & ENET_PDD_ETHERNET_BUS_ERROR_INT) {
    ENET_PDD_ClearInterruptFlags(ENET_BASE_PTR, ENET_PDD_ETHERNET_BUS_ERROR_INT);
    ETH_OnFatalError(DeviceDataPrv->UserDataPtr);
  }
}

/*lint -restore Enable MISRA rule (12.1,12.8,12.11) checking. */

/* END ETH */

#ifdef __cplusplus
}  /* extern "C" */
#endif 

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.09]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
